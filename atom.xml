<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>无知者のBlog 🤡</title>
  
  <subtitle>无所畏惧</subtitle>
  <link href="https://secondarylove.github.io/atom.xml" rel="self"/>
  
  <link href="https://secondarylove.github.io/"/>
  <updated>2022-02-17T06:11:11.176Z</updated>
  <id>https://secondarylove.github.io/</id>
  
  <author>
    <name>TT</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图片</title>
    <link href="https://secondarylove.github.io/2021/11/18/%E5%9B%BE%E7%89%87%E6%8F%8F%E8%BF%B0/%E5%9B%BE%E7%89%87/"/>
    <id>https://secondarylove.github.io/2021/11/18/%E5%9B%BE%E7%89%87%E6%8F%8F%E8%BF%B0/%E5%9B%BE%E7%89%87/</id>
    <published>2021-11-18T00:00:00.000Z</published>
    <updated>2022-02-17T06:11:11.176Z</updated>
    
    <content type="html"><![CDATA[<!-- ![图片描述名称八个字](https://raw.githubusercontent.com/secondarylove/blog-img/main/null1dc504ec70f1d0b4.jpg) -->]]></content>
    
    
      
      
    <summary type="html">&lt;!-- ![图片描述名称八个字](https://raw.githubusercontent.com/secondarylove/blog-img/main/null1dc504ec70f1d0b4.jpg) --&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>代码演示</title>
    <link href="https://secondarylove.github.io/2021/11/18/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/"/>
    <id>https://secondarylove.github.io/2021/11/18/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/</id>
    <published>2021-11-17T16:37:00.000Z</published>
    <updated>2021-11-18T08:53:58.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>dwadawd</p><h2 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h2><p>dwadwa</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;helo world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">代码块js的演示</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://secondarylove.github.io/2021/11/16/hello-world/"/>
    <id>https://secondarylove.github.io/2021/11/16/hello-world/</id>
    <published>2021-11-16T07:58:21.367Z</published>
    <updated>2022-02-17T06:12:12.266Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软件测试</title>
    <link href="https://secondarylove.github.io/2021/02/17/software%20test/index/"/>
    <id>https://secondarylove.github.io/2021/02/17/software%20test/index/</id>
    <published>2021-02-17T02:25:00.000Z</published>
    <updated>2022-02-17T06:01:09.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一次课"><a href="#第一次课" class="headerlink" title="第一次课"></a>第一次课</h2><p>课程目标</p><ol><li>   理解什么是测试</li><li>   理解软件生命周期</li><li>   了解常见研发组织</li><li>   理解什么是缺陷</li></ol><p>1.实例1<br>    极域出现网络适配器未找到</p><pre><code>问题：  1、软件版本    2、软件的安装过程    3、软件安装完成后的参数有没有设置正确    4、网卡，网络环境的测试</code></pre><p>  实例2 买衣服</p><pre><code>1）计划 - 羽绒服，价位多少？600-1000？品牌2）去哪里买 - 去商场买3）颜色：红色，灰色，黑色4）款式：长款，中长款，短款5）材质：羽绒80% 6）尺寸7）防水性 透气性8）洗涤方式9）价格10）售后，质保11）评价</code></pre><h2 id="一、-软件测试的目的"><a href="#一、-软件测试的目的" class="headerlink" title="一、 软件测试的目的"></a>一、 软件测试的目的</h2><pre><code>1.证明软件是可用的2.检测发现缺陷3.预防缺陷 - 分析已发现的bug,避免bug的重复出现</code></pre><h2 id="二、什么是软件测试"><a href="#二、什么是软件测试" class="headerlink" title="二、什么是软件测试"></a>二、什么是软件测试</h2><pre><code>IEEE 软件工程技术标准对软件测试的定义：采用手工或者自动化的手段，运行软件或直接观察软件的过程其目的是检验产品是否满足用户的需求，或弄清楚产品实际和需求之间的差别测试方法：手工或者自动化测试过程：运行软件或者直接观察软件运行的现象，或不运行软件，观察文档测试的根本目的：检验产品是否满足用户的需求：搞清楚产品实际和需求之间的差别问题：什么是缺陷缺陷：    不符合预期    错误:-error-    指在软件生存期内的不希望或不可接受的人为错误，其结果是                导致软件缺陷的产生。    缺陷:-defect-    软件或文档中不符合预期的表现，    失效:-failure-    功能部件执行其规定功能的能力丧失    故障:-fault-    在正式环境（生产环境）下缺陷暴露出来引发故障缺陷分类    1）额外实现的不需要的 -做多了    2）实现缺失 -做少了    3）实现错误 -做错了    4）可优化   -做的不完美</code></pre><h2 id="三、软件的生命周期"><a href="#三、软件的生命周期" class="headerlink" title="三、软件的生命周期"></a>三、软件的生命周期</h2><p>​    </p><pre><code>3.1 计划    角色：项目经理（产品经理）    工作内容：确立项目的目标，调研，沟通，评估可行性，资源，成本，进度，收益等。    输出：《项目计划》 愿景，使命，目标3.2 需求分析    角色：需求人员（项目经理，需求分析师，产品经理）    工作内容：解决软件做什么的问题，分析具体需求，逐步细化和定义    显式需求-明确提出    隐式需求-没有提出来但实际需要    输出：《需求规格说明书》《SRS 软件需求规格说明书》  Software Requirements Specification3.3 设计    角色：开发人员（架构师）    工作内容：怎么实现，如何实现（how）对系统 - 子系统 -模块 -函数进行    逐层设计    输出：《概要设计说明书-HLD》  high Level Design    《详细设计说明书-LLD》 Low Level Design3.4 编码    角色：开发工程师    工作内容：编写代码coding      输出：代码，可运行的程序3.5 测试    角色：测试工程师    工作内容：检查软件的质量    输出：《测试报告》《测试计划》《测试用例》《测试规程》《缺陷报告》3.6 运维    角色：运维人员，技术支持    工作内容：产品的运行维护，安装部署，升级更新，线上问题排查，培训。      输出：《运维报告》</code></pre><h2 id="四、瀑布模型"><a href="#四、瀑布模型" class="headerlink" title="四、瀑布模型"></a>四、瀑布模型</h2><pre><code>基于瀑布模型的软件生命周期    计划 需求（AT） 分析（st） 设计 (IT) 编码                                      测试 运维 特点：    1）串行的流程    2）测试到后期介入    3）一个测试师可负责多个项目    4）前期阶段做的越完善，后期的修改成本越低，交付质量就越高    缺点：    1）风险往往延至后期才能显露出来，失去及早纠正的机会    2）只能在项目后期才能看到成品    3）对需求变更的适应能力差    适合复杂度低，需求稳定的项目，通常周期较短</code></pre><h2 id="五、螺旋模型"><a href="#五、螺旋模型" class="headerlink" title="五、螺旋模型"></a>五、螺旋模型</h2><pre><code>瀑布模型的迭代版特点：    1）每一个螺旋类似于一个瀑布模型    2）分多次进行交付，在项目早期就能看到产品的雏形    3）风险能较早的暴露出来    4）对需求变更的适应能力更好缺点：    1）迭代次数多因而开发成本高，延迟最终交付的时间    2）适合复杂度高，需求可能有一定变化的项目，通常周期较长。</code></pre><h2 id="六、敏捷模型"><a href="#六、敏捷模型" class="headerlink" title="六、敏捷模型"></a>六、敏捷模型</h2><pre><code>螺旋模型的加速版本特点：        1）迭代周期短，1-2周；2)弱化文档，强调沟通，强调团队合作；    3）用户第一    适合需求不确定的项目</code></pre><h2 id="七、常见的研发组织"><a href="#七、常见的研发组织" class="headerlink" title="七、常见的研发组织"></a>七、常见的研发组织</h2><p>​    </p><pre><code>1）开发部--开发工程师前端开发工程师：h5页面；安卓：ios后端开发工程师：java python php c++ c# .net...数据库...2)测试部测试工程师 -QC测试开发工程师3）产品部产品经理需求工程师UI设计师4）质量部QA SQACMO 配置管理项目管理员：进度监督，进度协调</code></pre><h2 id="八、组织架构"><a href="#八、组织架构" class="headerlink" title="八、组织架构"></a>八、组织架构</h2><pre><code>按职能按项目矩阵混合类</code></pre><h2 id="九、测试过程"><a href="#九、测试过程" class="headerlink" title="九、测试过程"></a>九、测试过程</h2><p>​     </p><pre><code>9.1 学习目标    理解测试的四个阶段    理解测试的四个活动        理解测试的模型-双v模型9.2 测试的四个阶段单元测试 集成测试 系统测试 验收测试    9.2.1 单元测试 UT    u-unit T-test     针对软件系统的最基本单位进行测试（函数、类）        1.测试依据：《详细设计说明书》 LLD    2.测试对象：函数和类    3.测试重点：检查实现出来的代码是否和详细设计一致，            函数内部逻辑，各个函数的功能    4.测试方法：白盒测试为主    5.测试完整性的评估标准：逻辑覆盖率（语句的覆盖，判定的覆盖，路径的覆盖...）    6.由谁来执行：        一般由开发人员来执行，或者测试人员                                                                                                                          6.由谁来执行</code></pre><p>​            </p><pre><code>    9.2.2 集成测试  IT    将测试的每个单元，模块，子系统进行组装，检查他们之间的数据传递是否正确        也叫做组装测试。        1.测试依据：《概要设计说明书》 HLD    2.测试对象：接口    3.测试重点：检查实现出来的模块代码是否和概要设计保持一致            函数之间的相互调用是否正确，接口是否正确            模块的功能是否正确    4.测试方法：灰盒测试（介于白盒黑盒之间）    5.测试完整性的评估标准：接口覆盖率    6.由谁来执行：测试人员或者开发人员        9.2.3 系统测试 ST    将集成的系统作为一个元素和其他的软硬件结合一起做综合的测试叫系统测试。    （功能性、性能、兼容、可靠性、安全性....）        1.测试依据:SRS 《软件需求规格说明书》    2.测试对象：整个的软件系统    3.测试重点： 检查整个软件系统实现出来的功能性能是否和需求保持一致    4.测试方法：以黑盒测试为主    5.测试完整性的评估标准：需求覆盖率    6.由谁来执行：测试人员    9.2.4 验收测试 AT acceptance test    一般是指由客户参与的测试（第三方，用户）        1.测试依据:用户的原始需求，任务书，用户手册    2.测试对象：整个的软件系统    3.测试重点：检查整个软件系统实现出来的功能性能是否和用户需求保持一致    4.测试方法-分类        a.正式验收测试：由第三方评测机构来执行        b.用户验收测试：由用户执行            b1.α测试：用户到公司的内部进行测试使用                   受控：参与的人员经过筛选的，少量的                   使用的环境也是受控的，内部操作受控，在项目组的成员的陪同下进行，需要提供反馈                        例子（eg）：游戏封测：版本是未成熟的，有很多bug,禁止用户注册，只提供一些账号分给玩家试玩，                    如果发现了bug一定要告诉官方，官方才能修改.游戏内侧经历了封测，游戏进一步完善，                    给大部分玩家玩，账号难注册，返回bug            b2:β测试：用户场所进行测试                   不受控：参与的人员较多，使用真实环境 自由操作，不受控 可以反馈            eg:游戏公测：向广大玩家公开，注册的账号数量也没有限制，公测初期是免费的，随着玩家数量的增加，               但到了后期会逐渐的开始收费.    5.测试完整性的评估标准:用户需求覆盖率</code></pre><p>​        </p><pre><code>    9.2.5 对比        1)时间顺序不同        2)测试关注点不同        3)测试依据不同        4)测试完整性的评估标准不同        5)测试方法不同9.3 测试的四个活动    每个测试阶段，都可以细分为4个测试活动，这4个活动在每个阶段按时间顺序来进行    9.3.1 测试计划                角色：测试经理，测试组长(leader)                工作内容：从管理的角度来规划和控制整个测试工作的展开              测试范围，时间速度，人员分工，通过的标准        输出：《测试计划》 从管理的角度来规划和控制整个测试工作的展开    9.3.2 测试设计        角色：测试工程师                工作内容：选择什么样的测试方法，选择什么样的测试工具，选择什么样的测试策略        输出：《测试方案》 从技术角度来规划和控制整个测试工作    9.3.3 测试实现        角色：测试工程师                工作内容：编写测试用例，编写测试脚本，准备测试数据...        输出：《测试用例》 测试脚本 测试数据 测试规程...    9.3.4 测试执行        角色：测试工程师                工作内容：搭建测试环境；              准备测试的数据              执行测试用例并记录测试用例的执行结果                              提交缺陷报告                            输出：《缺陷报告》 《测试报告》 《总结报告》</code></pre><h2 id="十、回归测试"><a href="#十、回归测试" class="headerlink" title="十、回归测试"></a>十、回归测试</h2><pre><code>10.1 目的        验证缺陷是否修复；检查是否引入了新的缺陷10.2 回归测试的策略    10.2.1 完全回归        将所有的测试用例执行一次，工作量很大，一般很少采用    10.2.2 选择性回归        1) 覆盖修改法:哪里修改了就回归哪里        2)周边影响法：针对比较复杂的模块的修改，不仅要对测试修改过得内容，还要分析本次修改可能对其它哪些模块也产生                  ，凡是认为有影响的模块，也需要做回归测试。        3)指标达成法：按照一定的标准来选择需要回归测试的内容                  如：上次提交的所有缺陷对应的测试用例  100%                  有影响的模块对应的测试用例        100%                  核心模块的1、2级测试用例         100%</code></pre><h2 id="十一、测试模型"><a href="#十一、测试模型" class="headerlink" title="十一、测试模型"></a>十一、测试模型</h2><pre><code>11.1 V模型    本质上和瀑布模型一致    特点：        测试阶段和开发人员的工作对应        测试介入较晚        开发和测试串行工作11.2 双V模型    特点：                测试和开发可以并行开展工作        测试介入较早        测试准备和测试执行分离        越早准备越晚执行</code></pre><h2 id="十二、测试方法"><a href="#十二、测试方法" class="headerlink" title="十二、测试方法"></a>十二、测试方法</h2><pre><code>12.1 学习目标了解黑盒、白盒、灰盒、测试的方法了解静态、动态测试了解人工、自动化测试12.2 黑盒、白盒、灰盒测试    黑盒：把测试对象看成一个黑盒，只考虑整体的特性，不考虑内部的具体实现    主要使用在系统测试阶段    黑盒测试用例的测试方法：    等价类、边界值、判定表、正交实验、状态迁移、因果图、错误猜测...    白盒：将被测产品看做一个透明的盒子，针对内部逻辑进行测试        特点：只关注被测对象的实现细节，不关注外在特性。    主要用在单元测试阶段</code></pre><p>​        </p><pre><code>    灰盒：介于白盒和黑盒之间的一种测试                特点：既会关注被测对象的实现细节，也灰关注外在特性        一般用在集成测试阶段12.3 静态测试与动态测试    根据是否运行被测软件划分为静态测试与动态测试    静态测试 - 不运行被测软件                人工静态：同行评审，SRS HLD LLD 代码 测试计划 等        自动化静态：如编译    动态测是 - 运行被测软件        功能、性能、安全、兼容、易用、可靠性、可维护性、可移植性12.4 人工测试与自动化测试    人工测试是自动化测试的基础    自动化测试的优点：            稳定、速度快、效率高、解放人才                自动化测试保证软件的基本可用，而不是去发现更多的bug    自动化测试的局限性：        没有想象力、也没有创造力，也没有发散性思维        比如不合适审美类的测试        不合适需求不稳定，界面经常发生变化                不合适功能不稳定的时间进行测试        不合适不需要重复执行的测试        不合适周期短的测试项目</code></pre><p>​            </p><pre><code>        适合什么样的测试？        界面稳定，功能稳定，重复性高        回归测试：冒烟测试（预测试）、性能测试</code></pre>]]></content>
    
    
    <summary type="html">关于软件测试的笔记</summary>
    
    
    
    
  </entry>
  
</feed>
