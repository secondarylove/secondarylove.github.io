<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>无知者のBlog 🤡</title>
  
  <subtitle>无所畏惧</subtitle>
  <link href="https://secondarylove.github.io/atom.xml" rel="self"/>
  
  <link href="https://secondarylove.github.io/"/>
  <updated>2022-02-17T06:11:11.176Z</updated>
  <id>https://secondarylove.github.io/</id>
  
  <author>
    <name>TT</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图片</title>
    <link href="https://secondarylove.github.io/2021/11/18/%E5%9B%BE%E7%89%87%E6%8F%8F%E8%BF%B0/%E5%9B%BE%E7%89%87/"/>
    <id>https://secondarylove.github.io/2021/11/18/%E5%9B%BE%E7%89%87%E6%8F%8F%E8%BF%B0/%E5%9B%BE%E7%89%87/</id>
    <published>2021-11-18T00:00:00.000Z</published>
    <updated>2022-02-17T06:11:11.176Z</updated>
    
    <content type="html"><![CDATA[<!-- ![图片描述名称八个字](https://raw.githubusercontent.com/secondarylove/blog-img/main/null1dc504ec70f1d0b4.jpg) -->]]></content>
    
    
      
      
    <summary type="html">&lt;!-- ![图片描述名称八个字](https://raw.githubusercontent.com/secondarylove/blog-img/main/null1dc504ec70f1d0b4.jpg) --&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>代码演示</title>
    <link href="https://secondarylove.github.io/2021/11/18/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/"/>
    <id>https://secondarylove.github.io/2021/11/18/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/</id>
    <published>2021-11-17T16:37:00.000Z</published>
    <updated>2021-11-18T08:53:58.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>dwadawd</p><h2 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h2><p>dwadwa</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;helo world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">代码块js的演示</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://secondarylove.github.io/2021/11/16/hello-world/"/>
    <id>https://secondarylove.github.io/2021/11/16/hello-world/</id>
    <published>2021-11-16T07:58:21.367Z</published>
    <updated>2022-02-17T06:12:12.266Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软件测试第五次课笔记</title>
    <link href="https://secondarylove.github.io/2021/02/22/software%20test5/2022.2.22/"/>
    <id>https://secondarylove.github.io/2021/02/22/software%20test5/2022.2.22/</id>
    <published>2021-02-22T02:25:00.000Z</published>
    <updated>2022-02-22T12:57:59.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求管理"><a href="#需求管理" class="headerlink" title="需求管理"></a>需求管理</h1><h2 id="一、回顾一下软件的生命周期"><a href="#一、回顾一下软件的生命周期" class="headerlink" title="一、回顾一下软件的生命周期"></a>一、回顾一下软件的生命周期</h2><p>​    计划 、需求分析、设计、编码、测试、运维</p><p>​    项目计划    SRS需求规格说明书    概要设计    详细设计    代码、可运行程序    测试方案、计划、用    例、规程、缺陷报告</p><p>​    </p><p>​    </p><h2 id="二、测试工程师为什么要学习软件需求？"><a href="#二、测试工程师为什么要学习软件需求？" class="headerlink" title="二、测试工程师为什么要学习软件需求？"></a>二、测试工程师为什么要学习软件需求？</h2><p>​    展开测试工作的源头和基础——系统测试的分析和设计能力（测试人员的核心技能）</p><p>​    </p><p>​    参与需求评审（对需求质量要进行把控）——  一定的需求分析和评审能力（高级测试人员的必备    技能）</p><p>​    以用户的视角进行测试——在需求规格说明书之外，发掘和判断软件的实现和用户的</p><p>​    实际需求是否匹配（专家级测试人员的技能）</p><h2 id="三、学习目标"><a href="#三、学习目标" class="headerlink" title="三、学习目标"></a>三、学习目标</h2><p>​    1、理解什么是需求</p><p>​    2、理解需求开发管理过程活动</p><p>​    3、如何评审需求规格说明书</p><p>​    4、在整个过程活动中如何跟踪和管理需求</p><h2 id="四、什么是需求"><a href="#四、什么是需求" class="headerlink" title="四、什么是需求"></a>四、什么是需求</h2><p>​    需求的类型？</p><p>​        1、业务需求：</p><p>​                开源/节流/提高效率（一网通办——营商）</p><p>​        2、用户需求：</p><p>​                实际需求（问题、半成品的想法）存、取、查</p><p>​        3、系统需求：</p><p>​                硬件系统、软件系统</p><p>​        4、功能需求：</p><p>​        ……</p><h5 id="4-1-目标"><a href="#4-1-目标" class="headerlink" title="4.1    目标"></a>4.1    目标</h5><p>​                解决 （客户的）问题</p><p>​                满足  （客户的）需要</p><h5 id="4-2-形式"><a href="#4-2-形式" class="headerlink" title="4.2    形式"></a>4.2    形式</h5><p>​                正式文档（需求规格说明书）</p><h2 id="五、需求的开发管理过程活动——需求工程"><a href="#五、需求的开发管理过程活动——需求工程" class="headerlink" title="五、需求的开发管理过程活动——需求工程"></a>五、需求的开发管理过程活动——需求工程</h2><p>​    </p><h5 id="需求的开发"><a href="#需求的开发" class="headerlink" title="需求的开发"></a>需求的开发</h5><p>​            1、需求的获取：</p><p>​                        获取客户的原始需求（业务需求—高层的目标，比较粗）</p><p>​                            交付的类型：</p><p>​                                产品：“标准件”特征（潜在的客户（群）），可以卖给多个客户</p><p>​                                            市场调研：问卷调研，客户访谈</p><p>​                                            源型分析：竞品分析</p><p>​                                项目：“定制化”特征（特定的某客户），甲方（客户）提需求，</p><p>​                                            乙方量身定制。</p><p>​                                            项目标书</p><p>​            2、需求分析：</p><p>​                        将收集的需求、梳理、细化、搭建（概念）模型</p><p>​                                        ——发掘隐形需求</p><p>​                                        ——去伪存真                        </p><p>​            3、需求定义：</p><p>​                        精确的描述与定义</p><p>​                        SRS</p><p>​            4、需求验证：</p><p>​                        与用户验证需求</p><h5 id="需求的管理"><a href="#需求的管理" class="headerlink" title="        需求的管理"></a><font color="orange">        需求的管理</font></h5><p>​            1、需求分配:</p><p>​                        对大项目而言</p><p>​            2、需求评审：</p><p>​            3、需求基线：</p><p>​                        需求评审通过后，对需求建立基线</p><p>​            4、需求变更（变更控制）：</p><p>​                        建立基线后，若有变更，走变更流程</p><p>​            5、需求跟踪：</p><p>​                        跟踪需求的具体实现（避免有需求被遗漏；需求如果有变化，能很快的确认</p><p>​                        影响范围）</p><h2 id="六、如何评审需求规格说明书"><a href="#六、如何评审需求规格说明书" class="headerlink" title="六、如何评审需求规格说明书"></a>六、如何评审需求规格说明书</h2><h5 id="6-1、需求规格说明书-SRS"><a href="#6-1、需求规格说明书-SRS" class="headerlink" title="6.1、需求规格说明书    SRS"></a>6.1、需求规格说明书    SRS</h5><p>​                    定义：产品是要做什么以及做出什么样子（具体描述：输入+处理+输出）</p><p>​                    </p><p>​                    核心内容：</p><p>​                            功能需求</p><p>​                                        用户接口：人机交互接口（软件界面）</p><p>​                                        软件接口：与外部软件的接口（子系统之间、与第三方系统之间）</p><p>​                            非功能需求：</p><p>​                                        性能需求</p><p>​                                        安全性需求</p><p>​                                        易用性</p><p>​                                        …..</p><p>​                    其他内容</p><p>​                            产品所需的环境介绍（软、硬件配置）</p><p>​                            需求分级：</p><p>​                                        需求优先级：</p><p>​                                                    基本级：必须要的、如果缺少、软件就不完整</p><p>​                                                    条件级：次要功能，增加软件的竞争力</p><p>​                                                    可选级：可有可无，增加用户体验</p><p>​                                        用户特征（画像）</p><p>​                                                    软件给谁用</p><p>​                                        假设和依赖关系</p><p>​                                                    开发的语言、环境</p><p>​                                        本地化</p><p>​                                                    符合不同区域的文化特征</p><p>​                                        标准的符合性</p><p>​                                                    国际标准、国家标准、行业标准、企业（内部）标准</p><p>​                                        技术限制</p><p>​                                                    技术瓶颈</p><p>​                    </p><p>​                    SRS的6大特性：</p><p>​                                        正确性</p><p>​                                        无歧义性：有点儿长，比较大等等都不行</p><p>​                                        完整性：无遗漏</p><p>​                                        一致性：文档描述要前后一致</p><p>​                                        可验证性：所有的描述要可量化，可测试</p><p>​                                        可追踪性：每个需求需要有唯一编号</p><h5 id="6-2、同行评审技术"><a href="#6-2、同行评审技术" class="headerlink" title="6.2、同行评审技术"></a>6.2、同行评审技术</h5><p>​                定义：由”同行“来检查工作成果是否有问题</p><p>​                        ——（广义）凡是参与评审的人或与评审相关的人都称为“同行”</p><p>​                目的：尽早的纠正研发过程中工作成果的问题，减少后期工作的修正与返工</p><p>​                            时间。</p><p>​                参与评审人员：有的时候是同行；有时候是和项目相关的各个角色；</p><p>​                常见的被评审物：</p><p>​                            管理类：xxx计划</p><p>​                            技术类：基础类的SRS、HLD（HLD）、代码、测试计划、用例、报告…</p><p>​                按正规的程度</p><p>​                            正规的检视：最正式、最严格、最耗时（仅针对重要的，基础性的技术类</p><p>​                                                    工作成果）</p><p>​                            技术评审：较正式、只需要有评审会议</p><p>​                            走查：互相检查、不开评审会议<br><img src="https://raw.githubusercontent.com/secondarylove/blog-img/main/%E8%AF%84%E5%AE%A1.png"></p><h5 id="6-3、需求评审"><a href="#6-3、需求评审" class="headerlink" title="6.3、需求评审"></a>6.3、需求评审</h5><p>​                    被评审物：SRS</p><p>​                    参与人员：项目经理（产品经理），需求分析师、测试、开发、甲方客户</p><p>​                    目的：</p><p>​                            1、保证项目组所有成员（参与需求评审的人员），对需求的理解一致性</p><p>​                            2、是否符合6大特性（重点：错的、漏的、前后矛盾的、有歧义的、没有</p><p>​                                    描述到位的）</p><p>​                            3、保证产品，系统从开发的角度和测试的角度，具备可实践性</p><p>​                                            开发：技术上是否可实现</p><p>​                                            测试：评估可测性，作为专家级测试，在用户的角度输出需求建议</p><p>​                            </p><p>​                    需求评审的方法和技术（同行评审之正规检视）</p><p>​            <img src="https://raw.githubusercontent.com/secondarylove/blog-img/main/%E8%AF%84%E5%AE%A1%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E6%9C%AF.png"></p><p>​            <img src="https://raw.githubusercontent.com/secondarylove/blog-img/main/%E8%AF%84%E5%AE%A1%E6%B5%81%E7%A8%8B.png"></p><h2 id="七、在过程活动中，如何跟踪需求"><a href="#七、在过程活动中，如何跟踪需求" class="headerlink" title="七、在过程活动中，如何跟踪需求"></a>七、在过程活动中，如何跟踪需求</h2><h5 id="7-1、需求的跟踪、变更流程图"><a href="#7-1、需求的跟踪、变更流程图" class="headerlink" title="7.1、需求的跟踪、变更流程图"></a>7.1、需求的跟踪、变更流程图</h5><img src="https://raw.githubusercontent.com/secondarylove/blog-img/main/%E9%9C%80%E6%B1%82.png"><h5 id="7-2、需求变更"><a href="#7-2、需求变更" class="headerlink" title="7.2、需求变更"></a>7.2、需求变更</h5><img src="https://raw.githubusercontent.com/secondarylove/blog-img/main/%E9%9C%80%E6%B1%82%E5%8F%98%E6%9B%B4.png"><h2 id="八、其他"><a href="#八、其他" class="headerlink" title="八、其他"></a>八、其他</h2><img src="https://raw.githubusercontent.com/secondarylove/blog-img/main/%E5%85%B6%E4%BB%96.png">]]></content>
    
    
    <summary type="html">关于软件测试的笔记配置管理</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>软件测试第四次课笔记</title>
    <link href="https://secondarylove.github.io/2021/02/21/software%20test4/2022.2.21/"/>
    <id>https://secondarylove.github.io/2021/02/21/software%20test4/2022.2.21/</id>
    <published>2021-02-21T02:25:00.000Z</published>
    <updated>2022-02-21T14:16:29.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h1><h3 id="一、-回顾一下：瀑布模型"><a href="#一、-回顾一下：瀑布模型" class="headerlink" title="一、  回顾一下：瀑布模型"></a>一、  回顾一下：瀑布模型</h3><p>计划——需求（需求分析）——设计——编码——测试——运维<br>项目计划书——需求规格说明书——概要设计&amp;详细设计——源代码&amp;运行系统——测试计划（测试方案），测试用例，测试结果报告（缺陷报告）——运维手册<br>项目经理——需求分析师——开发人员——开发人员——测试人员——运维人员</p><p>仓库：SCM（软件配置管理）</p><p><font color="red">仓库的管理员：CMO（Configuration    Management Officer-配置管理员）</font></p><h3 id="二、-测试人员为什么要学习配置管理"><a href="#二、-测试人员为什么要学习配置管理" class="headerlink" title="二、  测试人员为什么要学习配置管理"></a>二、  测试人员为什么要学习配置管理</h3><p>日常工作之一：上传&amp;下载：</p><p>​        上传：对测试的工作成果进行（提交、修改、再提交）管理</p><p>​        下载：获取最新的需求；获取开发设计文档</p><p>检出或确认正确的被测试程序（或软件）</p><h3 id="三、-学习目标"><a href="#三、-学习目标" class="headerlink" title="三、   学习目标"></a>三、   学习目标</h3><p>了解 配置管理的工作内容</p><p>理解配置管理的基本概念</p><p>了解版本控制的重要性</p><p>通过工具软件svn,掌握配置管理和变更的基本流程</p><h3 id="四、-什么是配置管理"><a href="#四、-什么是配置管理" class="headerlink" title="四、    什么是配置管理"></a>四、    什么是配置管理</h3><p>​    配置：</p><p>​        组成产品的：工作成果的结合+版本标识</p><p>​    配置项：</p><p>​            1、文档（含软、硬件配置 ）</p><p>​            2、代码及运行的系统（含第三方）</p><p>​            3、工具</p><p>​    配置管理：</p><p>​            项目全过程中，对所有工作产出物，进行</p><p>​            <font color="red">——–（版本）标记</font></p><p>​            <font color="red">———（增/删/改/读取）权限控制</font></p><p>​            管理的工作内容：</p><p>​                1）配置管理计划</p><p>​                2）配置项的管理和维护</p><p>​                3）版本控制</p><p>​                4）变更控制</p><p>​            目标：保证所有工作产物的完整性、一致性、可跟踪性。</p><p>​            <strong>术语</strong>：</p><p>​            <font color="orange">    SCM（Software Configuration Managment -软件配置管理）</font></p><p>​                <font color="orange">CMO（Configuration    Management Officer-配置管理员）</font></p><p>​            <font color="orange">    CI（Configration     Item–配置项）</font></p><p>​            <font color="orange">    CR（Change    Request—变更请求）</font></p><p>​            <font color="orange">    CCB（Change    Control    Board    —变更控制委员会）</font></p><h3 id="五、-什么是版本控制"><a href="#五、-什么是版本控制" class="headerlink" title="五、    什么是版本控制"></a>五、    什么是版本控制</h3><p>​        定义：不同迭代，产出物的标识。</p><p>​        v：version</p><p>​        r：release</p><p>​        </p><p>​        <font color="orange">版本命名方式：一般是四个字段（主版本号.子版本号    【.修正版本号】【.编译版本号】）</font></p><p>​        </p><p>​                WPS：v11.0.0.0    HarmonyOS：2.0.0</p><p>​        主版本号：软件增加了一个大特性，与原版本可能不兼容</p><p>​        eg：新生成的文件，老版本打不开，即文件格式不兼容</p><p>​        子版本号：软件增加一个小的特性，与原版本兼容</p><p>​        eg：老版本有左对齐功能，新版本新增了居中对齐，右对齐</p><p>​        修正版本号：对前一个版本发补丁（patch）</p><p>​        eg：修复了闪退，运行不稳定，耗电快</p><p>​        编译版本号：通常由编译器自动生成（补丁的补丁）</p><p>​        BA:Business    Analysls（需求分析人员）</p><p>​        基线（baseline）</p><p>​                    里程碑（milestone）：项目开发过程中一个重要的阶段点，标志着某个项目</p><p>​                    的任务的完成。</p><p>​                    基线化：某工作成果，已通过评审，进入正式受控（冻结不可再修改）的一种状态。</p><p>​                                    特点：</p><p>​                                        1）基线版本不允许再次修改</p><p>​                                        2）基线版本是下一次迭代的基准</p><p>​                    基线的变更</p><p>​                            基线变更为何要走流程</p><p>​                                        需求变更的原因：甲方需要追加/出去功能，技术无法实现</p><p>​                                        Q;测试模型：</p><p>​                                                    计划</p><p>​                                                    需求</p><p>​                                                            用户需求    ————验收测试（设计）——执行</p><p>​                                                            需求分析    ————系统测试（设计）——执行</p><p>​                                                    设计</p><p>​                                                            概要设计    ————集成测试（设计）——执行</p><p>​                                                            详细设计    ————单元测试（设计）——执行</p><p>​                                                    编码</p><p>​                                                    测试</p><p>​                                                    运维</p><p>​<img src="https://raw.githubusercontent.com/secondarylove/blog-img/main/jd.jpg"></p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><img src="https://raw.githubusercontent.com/secondarylove/blog-img/main/%E6%B5%81%E7%A8%8B.png"><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><img src="https://raw.githubusercontent.com/secondarylove/blog-img/main/%E8%AF%B4%E6%98%8E.png"><p>​                                                    版本发布：测试（内侧）——主板（发布）</p><h2 id="六、-配置管理工具"><a href="#六、-配置管理工具" class="headerlink" title="六、    配置管理工具"></a>六、    配置管理工具</h2><p>​            SVN（集中式管理）    &amp;    GIT（分布式管理）</p><p>​            分支（branch）</p><h2 id="七、SVN：版本控制器"><a href="#七、SVN：版本控制器" class="headerlink" title="七、SVN：版本控制器"></a><font color="orange">七、SVN：版本控制器</font></h2><p>​            7.1    服务器</p><p>​                    Releasenote.txt   需求分析里面写的  发布说明书</p><p>​                    VisualSVN-Server-Manager</p><p>​                    CMO进行操作</p><p>​                                安装服务器软件（VisualSVN）</p><p>​                                1.盘符</p><p>​                                2.端口号（8443）</p><p>​                                进入服务器：开始—》</p><p>​                                所有程序—》</p><p>​                                VisualSVN—》</p><p>​                                VisualSVN Server Manager</p><p>​                            建立仓库：Repositories右键—-》新建—-》Repository–&gt;输入仓库名称</p><p>​                            建立用户：users右键—》新建—》user—&gt;输入用户名与密码</p><p>​                            用户授权：在仓库上右键—》properties .. —&gt; 选择要加入的用户—》点击add</p><p>​            7.2    客服端</p><p>​                    TortoiseSVN</p><p>​                    所在项目成员进行的操作</p><p>​                                    安装客服端（TortoiseSVN）</p><p>​                                    1.盘符</p><p>​                                    2.在文件夹中右键，这时右键菜单中出现TortoiseSvn</p><p>​                                项目经理：</p><p>​                                            首次导入：新建好项目的管理文件夹结构，右键TortoiseSvn    import（导                                            入）至服务器端的仓库，项目开始的时候，只执行一次</p><p>​                        </p><p>​                    1、建文件夹（再有文件）</p><p>​                    2、文件夹的空白处右键—-》Tsvn—&gt; import (签入)—》输入服务器的URL;https://服务器                    的   IP地址:svn端口/svn/仓库名称/—-》输入：用户名与密码</p><p>​                    —— 客户端在使用import之后，服务器端(VisualSVN Server Manager) 点击 “刷新” 图                    标，可 看到新导入的项目目录</p><p>​                 注意：设置好项目的目录结构（模板），import之后，该项目目录结构可以删除</p><p>​                —— 然后执行checkout（签出），新的项目目录才是在svn的管理之下</p><p>​                其他人员：</p><p>​                首次签出（Checkout）项目。一般一个人只执行一次</p><p>​                新建，文件夹：–》 </p><p>​                在文件夹内部空白处，右键—-》</p><p>​                checkout–&gt; </p><p>​                输入 服务器的URL:https://服务器的 IP地址:svn端口/svn/仓库名称/文件夹名称</p><p>​                所有项目人员（日常工作（1））</p><p>​                更新（update）：将服务器上的最新内容，更新至本地工作空间。</p><p>​                服务器 》本地</p><p>​                </p><p>​                1、本地项目目录的空白处 右键—》update</p><p>​                —— 本地版本同步为与服务中的版本相同</p><p>​                提交（commit）：对本地文件进行增加，删除，修改之后，提交更新至服务器端</p><p>​                增加文件/文件夹：</p><p>​                1、创建文件—-》空白处右键—》TSVN—&gt;add</p><p>​                2、空白处右键—》commit提交</p><p>​                3、观查：版本自动号增1</p><p>​                    删除文件</p><p>​                    删除文件/文件夹之后</p><p>​                1、空白处右键—》commit提交</p><p>​                2、选择删除的文件</p><p>​                3、点击确定</p><p>​                修改</p><p>​                1、修改文件，并保存</p><p>​                2、空白处右键—》commit提交</p><p>​                1、要提交至服务器，都必须有 commit 提交</p><p>​                2、任何人的任何一次 commit，svn的自带版本号(revision) 均会自增1</p><p>​                日常工作流程</p><p>​                \1. 每天开始工作前，update</p><p>​                \2. 完成自己的工作（更新自己的文件）</p><p>​                (1)  每完成一个文件的修改，提交之前，update</p><p>​                (2)  再执行 commit</p><p>​                无冲突，提交成功完成</p><p>​                —— 本地与服务器文件完成同步，两者版本保持一致</p><p>​                出现冲突，提示不成功</p><p>​                ——解决冲突</p><p>​                产生的原因：</p><p>​                本地修改的文件被 commit时</p><p>​                ——SVN首先检测：服务器上该文件的 <strong>当前</strong>版本，是否依旧是本地该文件<strong>被修改前</strong>的版                  本。</p><p>​                如果不是，则提示有冲突 —— 说明有人恰巧在你<strong>更改此文件期间</strong>，已经更新了服务器上                     此文件</p><p>​            </p><p>​    <img src="https://raw.githubusercontent.com/secondarylove/blog-img/main/%E5%86%B2%E7%AA%81.png"></p><p>​                对于文本文件（例如：源代码，.txt文件）</p><p>​            1、自动解决：两人修改的是同一个文件的不同行，update-&gt;(merge - 自  动合并修改) -                &gt;commit</p><p>​            2、手动解决：两人修改的是同一个文件的同一行。</p><p>​            (1)    双方协商，确定正确的逻辑，后者修改合并文件</p><p>​            (2)    后者删除本地的中间过程文件</p><p>​            (3)    再 commit</p><p>​            对于非文本文件 (例如：docx， pdf 等文件）</p><p>​            1、手动解决：…</p><p>​            所有项目人员（日常工作（2））</p><p>​            Show log：显示日志信息，看注释</p><p>​            Diff：比较与前一个版本的区别（例如：查看代码的变化）</p><p>​            Update to this version: 回退到指定版本</p><p>​            Checkout 指定版本（例如：从前一个版本开发新功能）</p><p>​            所有项目人员（其他操作）</p><p>​            分支</p><p>​        应用场景：多版块，多团队，需并行开发不相互干扰，各团队需从稳定的主干中，分离出  各自的        分支，进行开发，开发测试达标后，再陆续的合并回主干</p><p>​        1、在需要分支的文件夹空白处，右键—》TSVN–&gt;branch/tag —-&gt;在to path:to path中输  入或        选择要打分支到哪一个文件夹下;输入不存在的文件夹,那么会自动在SVN中创建该文   件夹</p><p>​        2、观参：版本号自增1，主空间中的没有分支文件夹的</p><p>​        3、创建分支的工作空间—chechout–&gt;分支</p><p>​        4、分支的工作空间—》修改—》commit，update</p><p>​         </p><p>​        发布的版本：svn : tag</p><p>​        —— 迁出分支，不允许修改</p><p>​        注：在服务器上创建一个放分支的文件夹</p><p>​        合并分支</p><p>​        1、选择原文件夹空白处 –》右键 –》</p><p>​        TSVN–&gt;merge –&gt;next</p><p>​        –&gt;在url to marge from 中选择分支的路径 –》</p><p>​        next—&gt;test marge测试 —》merge</p><p>​        1、Commit</p><p>乐观锁：自动合并（系统完成：修改 – 合并）</p><h2 id="八、总结5W1H"><a href="#八、总结5W1H" class="headerlink" title="八、总结5W1H"></a>八、总结5W1H</h2><p>​        WHO：</p><p>​                管理者：项目经理+CMO+CCB</p><p>​                使用者：全体项目成员</p><p>​        WHAT：</p><p>​                管理者：</p><p>​                        1、构建并管理号仓库及其内容</p><p>​                        2、进行版本控制、变更控制</p><p>​                </p><p>​                使用者：</p><p>​                        1、检出总结所需文档、代码</p><p>​                        2、提交总结的工作产物</p><p>​        WHEN</p><p>​                    整个软件或迭代交付生命周期</p><p>​        WHERE</p><p>​                    服务器：放置仓库</p><p>​                    客户端：项目组成员的机器上</p><p>​        WHY</p><p>​                1、文档/代码等等的分发，获取与交付</p><p>​                2、版本控制</p><p>​                3、变更控制</p><p>​        HOW</p><p>​                ………</p><p>​            作业</p><p>​            \1. 新建一个“电商平台”项目仓库</p><p>​            \2. 导入如下项目结构（两个开发团队，分别开发两个版块）</p><p>​            - 首页版块</p><pre><code>      \- 需求文档</code></pre><p>​          - 设计及代码</p><p>​          - 测试文档</p><p>​        - 采购版块</p><pre><code>      \- 需求文档      \- 设计及代码</code></pre><p>​          - 测试文档</p><p>​        \3. 在一个本地目录中，检出以上两个项目</p><p>​        \4. 在 首页版块 - 需求文档 中，追加 release.txt</p><p>​        \5. 更新项目</p><p>​        \6. 修改 该 release.txt 后重新提交</p><p>​        \7. 本地回退至上一个版本</p>]]></content>
    
    
    <summary type="html">关于软件测试的笔记</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>软件测试第二次课笔记</title>
    <link href="https://secondarylove.github.io/2021/02/19/software%20test2/2022.2.19/"/>
    <id>https://secondarylove.github.io/2021/02/19/software%20test2/2022.2.19/</id>
    <published>2021-02-19T02:25:00.000Z</published>
    <updated>2022-02-20T12:55:06.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、课程目标"><a href="#一、课程目标" class="headerlink" title="一、课程目标"></a>一、课程目标</h2><pre><code>了解什么是软件的质量了解质量的铁三角理解软件的质量模型了解常见的质量管理体系了解QA的工作pidp-process 进程id 号PDCA 循环（质量环） (戴明环) P-plan(计划)D（Do)--执行；C（CHECK)--检查；A（Action)--行动石川  提出因果分析图，也叫鱼骨图（石川图）可结合 佐吉 提出的“swhy”法更好用6西格玛   6个西格玛，代表百万样品中只有3-4个残次品</code></pre><p>​    </p><h2 id="二、什么是质量"><a href="#二、什么是质量" class="headerlink" title="二、什么是质量"></a>二、什么是质量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">案例： 换手机，手机用了5年，换一个质量更好的手机。</span><br><span class="line"></span><br><span class="line">1.品牌</span><br><span class="line">Apple 华为 小米 oppo vivo 三星 杂牌</span><br><span class="line"></span><br><span class="line">2.价格</span><br><span class="line">不超1w,贵了华而不实，质量对不起价格。</span><br><span class="line"></span><br><span class="line">3.功能</span><br><span class="line">支持人脸识别，nfc，拍照，无线充电,双卡双待，支持5G，定位导航，蓝牙wifi</span><br><span class="line">通话质量</span><br><span class="line"></span><br><span class="line">4.性能</span><br><span class="line">Cpu 内存ram(8G或16G),存储空间rom（256G，512G），安兔兔跑分，拍照性能，</span><br><span class="line">电池性能，屏幕像素，刷新率，游戏性能（流畅度，发热），防尘防水 ip68 </span><br><span class="line"></span><br><span class="line">5.外观</span><br><span class="line">银色 黑色 白色；尺寸（不小于6英寸），材质（铝合金，玻璃）直板</span><br><span class="line"></span><br><span class="line">6.售后服务，维修</span><br><span class="line"></span><br><span class="line">2.1质量的定义</span><br><span class="line">    ISO 对质量的定义：一个实体的所有特性，基于这些特性可以显式需求或者隐式需求。</span><br><span class="line">    质量就是实体基于这些实体特性满足需求的程度</span><br><span class="line">    </span><br><span class="line">    I-international</span><br><span class="line">    S-  standard</span><br><span class="line">    O-organization</span><br><span class="line">    </span><br><span class="line">    2.1.1 什么是实体</span><br><span class="line">    </span><br><span class="line">    产品本身</span><br><span class="line">    产品服务</span><br><span class="line">    </span><br><span class="line">    实体就是测试对象</span><br><span class="line">    </span><br><span class="line">    2.1.2 实体的特性</span><br><span class="line">    </span><br><span class="line">    饿了么</span><br><span class="line">    1）软件本身：功能完整，运行流畅，点餐方便 支持哪些商家</span><br><span class="line">    2）服务：送餐速度，超时补偿 </span><br><span class="line">    态度</span><br><span class="line">    买一款榨汁机，质量特性：</span><br><span class="line">    1）功能</span><br><span class="line">    2）性能</span><br><span class="line">    3）安全性</span><br><span class="line">    4）可靠性</span><br><span class="line">    5）易用性</span><br><span class="line">    6）耗能</span><br><span class="line">    7）服务</span><br><span class="line">    </span><br><span class="line">    软件到底有哪些特性？</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="三、软件质量模型"><a href="#三、软件质量模型" class="headerlink" title="三、软件质量模型"></a>三、软件质量模型</h2><pre><code>McCall, Boehm, ISO 9126, ISO 25010    ISO  25010</code></pre><h5 id="3-1-功能适用性"><a href="#3-1-功能适用性" class="headerlink" title="3.1 功能适用性"></a>3.1 功能适用性</h5><pre><code>        当软件在指定条件下使用的时候，软件产品提供满足显式和隐式的功能需求的能力        3.1.1 完整性                    提供的所有功能是否完整                    手机：通话，短信，上网，拍照 WIFI 充电 ...                    显式器：显示信号，亮度调整，对比度，色调设置，接口 VGA HDMI                            3.1.2 适合性                    提供的某个功能本身是否完善（完整性关注整体功能的完整性，                    适合性关注个体功能的完整性）                    3.1.3 正确性                    提供的功能是否正确（对不对）</code></pre><h5 id="3-2-运行效率（性能）-自动化测试工具-Load-Runner-Jmeter"><a href="#3-2-运行效率（性能）-自动化测试工具-Load-Runner-Jmeter" class="headerlink" title="3.2 运行效率（性能） (自动化测试工具 Load Runner  , Jmeter)"></a>3.2 运行效率（性能） (自动化测试工具 Load Runner  , Jmeter)</h5><pre><code>            在规定条件下，软件产品可提供适当性能的能力                3.2.1 时间特性                            1）响应时间（如 页面的响应的时间，操作的响应时间） 2-5-8原则                            2）页面切换时间：站点不同页面之间进行切换的时间                            3）并发 （双11同时有大量用户购物和平时，秒杀活动）                3.2.2 资源占用率                            在规定的条件下，相对于所用资源数量，软件产品可以提供适当性能的能力                            （如cpu的占用率，内存的占用率，网络宽带的占用率等）                                eg: 任务管理器-进程页面可以查看                3.2.3 容量                            软件最大程度满足需求的能力                            eg1.电商网站双11活动  秒杀                            并发登录人数                            并发下单人数                            同时在线人数  (bbs)-论坛                            eg2.硬盘  控制面板 - 设备管理器- 磁盘驱动器                            eg3.微信最多加5000个好友   不包括群聊和公众号                            eg4.icould空间:5g免费空间</code></pre><h5 id="3-3-易用性"><a href="#3-3-易用性" class="headerlink" title="3.3 易用性"></a>3.3 易用性</h5><pre><code>                在指定的条件下使用时，软件产品被理解，学习，使用和吸引用户的你能力（容易使用）                    3.3.1 可辨识性                                用户可以快速的判断是否是自己想要的。直观的设计                    3.3.2 易学性                                帮助用户自行学习系统                                帮助手册，操作手册，操作视频                                使用引导页面                    3.3.3 易操作性                                操作步骤少                                    eg.常用的功能操作，菜单级数，进入系统后点击操作少于三步                                    eg.快捷键 ctrl C  ctrl V  ctrl A  ctrl S ctrl Z,F, tab 切换  上下左右导航                                     右键 菜单                                    eg.登录时记住上一次的登录的用户名                    3.3.4 用户错误保护                                避免用户输入错误                                    eg.输入框文案提示                                        .输入错误有提示                                        .页面，输入框的提示</code></pre><p>​                        </p><pre><code>                    3.3.5 用户界面美观                                能提高用户的喜悦度和满意度的配色，图形设计，图形文字的比例...                     3.3.6 可访问性                                被人使用最广泛的特性</code></pre><p>​                                </p><h5 id="3-4-兼容性"><a href="#3-4-兼容性" class="headerlink" title="3.4 兼容性"></a>3.4 兼容性</h5><pre><code>            定义：同时共享相同的硬件或软件时，没有不利的影响（没有冲突，互不影响）            3.4.1 共存性                         与其他产品共享一个共同的环境和资源，没有不利的影响（没有冲突，互不影响）                                eg.杀毒软件误杀            3.4.2  互操作性                        两个或者两个以上的系统，产品，或部件可以交换信息，并使用已经交换的信息的额                            程度                            eg1. Word打印，可以支持不同的打印机                            1）浏览器的兼容  chrome firefox ie                            2）操作系统的兼容                            3）分辨率                            4）手机型号</code></pre><h5 id="3-5-安全性"><a href="#3-5-安全性" class="headerlink" title="3.5 安全性"></a>3.5 安全性</h5><pre><code>            产品或系统保护信息和数据，方便人员或其他系统对信息和数据访问的程度。                3.5.1 保密性                            数据不会泄露，防窃取。                            加密存储，加密传输。                                eg.软件系统密码加密后存储                                eg. https 协议是加密传输，web应用都会采用https协议传输，而非http协议                                        （不保密）                                http:1）无状态，协议对客户端没有状态存储，对事物处理没有记忆能力，比如                                        访问一个网站需要反复进行登录操作。                                        2）无连接，每次请求都需要通过三次握手和四次挥手，和服务器建立连接                                        3）通信使用明文，请求和响应不会和通信方确认，无法保护数据的完整                                                  性。                                https:内容加密，采用混合加密技术，中间者无法直接查看明文内容，验证身份                                            ，通过证书认证客户端确认访问自己的服务器，保护数据的完整性，防止                                            内容被中间人，篡改或冒充。</code></pre><p>​                        </p><pre><code>                3.5.2 完整性                            数据不会破坏，防篡改防丢失。                            eg.加密传输加密存储，备份                3.5.3 不可抵赖性                            已经发生的操作，不可否认，软件系统要有证据                            系统的操作日志      软件信息的状态（已查看，已读）</code></pre><p>​                                        </p><pre><code>                3.5.4 可核查性                            发生过得操作，可查的，系统操作日志可查，什么时候，什么模块做了什么操作？</code></pre><p>​                                </p><pre><code>                3.5.5 真实性                            使用者的身份可被证明</code></pre><h5 id="3-6-可靠性"><a href="#3-6-可靠性" class="headerlink" title="3.6 可靠性"></a>3.6 可靠性</h5><pre><code>            在规定的时间和条件下，软件能维持其正常功能操作和性能水平的程度。            3.6.1 成熟性                        软件能很好的处理软件内部的错误，不会出现异常            3.6.2 易恢复性                        出现异常后 能否恢复？要过多长时间可以恢复？能恢复到什么程度？                        word自动保存的设置（文件-选项-保存-自动保存设置），                        迅雷下载文件过程中断网或者异常关机，可以继续下载                        迅雷下载文件过程中断网或者异常关机            3.6.3 容错性                        软件能很好的处理外部错误或异常输入，不会出现异常。                        断网（信号被屏蔽或者插网线）                        断电 （电池耗尽，电池跳闸)            3.6.4 可用性                        是成熟性，容错性和易恢复性的组合                        系统的可用性，系统正常运行的时间占总时长的比例（故障，宕机）</code></pre><h5 id="3-7-可移植性"><a href="#3-7-可移植性" class="headerlink" title="3.7 可移植性"></a>3.7 可移植性</h5><pre><code>            软件产品从一种环境迁移到另一种环境的能力            3.7.1 适用性                        软件产品无需采用特别的 手段就可以适应不同指定环境的能力                        环境 - 操作系统，浏览器，分辨率                        浏览器：                                    IE : Trident                                    Chrome：Webkit                                    FireFox：Gecko                                    Sarafi：Webkit                                    QQ浏览器极速版：Webkit                                                        普通版：Trident            3.7.2 易安装性                        软件产品在指定环境中被安装的能力                        1）命令行安装                        2）图形界面安装                        3）免安装（绿色安装）            3.7.3 易替换性                        软件产品在同样的环境下替换一个相同用途的指定软件产品的能力                        升级 - 自己替换自己                        不同软件之间的替换</code></pre><h5 id="3-8-可维护性"><a href="#3-8-可维护性" class="headerlink" title="3.8 可维护性"></a>3.8 可维护性</h5><pre><code>            产品可被修改的能力            3.8.1 模块化                         将功能相似的函数组合在一起成为一个模块 提供一个较为复杂的功能，可以复用。            3.8.2 可复用性                         相识的功能不再重新写代码            3.8.3 易分析性                         便于评估和诊断，比如出错提供出错日志，从用户处收集数据            3.8.4 易修改性                         代码符合规范，注释完备，逻辑清晰，模块层次分明            3.8.5 易测试性                         容易测试，提供注释行 ，提供日志      </code></pre><h2 id="四、产品质量的种类"><a href="#四、产品质量的种类" class="headerlink" title="四、产品质量的种类"></a>四、产品质量的种类</h2><pre><code>        1）过程质量                过程执行的完整度和执行的力度。                SQA : S:    software    Q:    quality     A:    assurance        2）产品质量                软件研发过程中，工作成果物（文档，代码） 以及最终产品的质量                QC: quality control(测试工程师)        3）使用质量                用户在真实环境中运行软件系统时，所感受到的软件各方面特性与需求符合的程度。</code></pre><h2 id="五、软件质量铁三角"><a href="#五、软件质量铁三角" class="headerlink" title="五、软件质量铁三角"></a>五、软件质量铁三角</h2><pre><code>            1）组织                    公司对质量管理的重视度，专业独立的测试团队，对专业人才流程技术的引进            2）流程                    质量管理体系：                    软件能力成熟度模型                    ----CMMI  Capability Maturity Model Intergration                        一共分为5级:                        1    初始级    最低：混乱无序                        2    可重复级            有基本流程                        3    已定义级                标准化                        4    已管理级                可量化                        5    优化级    最高：量化反馈，不断改进                    工作流程；研发流程；测试流程；缺陷管理流程；评审流程...            3）技术                A）技术人才                B）专业的知识：数据库技术，网络协议知识，软件质量模型...                C）专业技能                        测试分析技能（需求分析，用例设计）                        评审技术                        技术框架                        各种工具：                        SVN    禅道                        测试工具：jmter  ，load runner ，postman ，burpsuit（安全测试），                        emmage（app性能）</code></pre><h2 id="六、软件质量的3个层次"><a href="#六、软件质量的3个层次" class="headerlink" title="六、软件质量的3个层次"></a>六、软件质量的3个层次</h2><pre><code>    1层：符合需求规格    2层：符合用户的显式需求    3层：符合用户的实际需求 （实际需求包括显式和隐式需求）</code></pre><p>​                    </p>]]></content>
    
    
    <summary type="html">关于软件测试的笔记</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>软件测试第三次课笔记</title>
    <link href="https://secondarylove.github.io/2021/02/19/software%20test3/2022.2.20/"/>
    <id>https://secondarylove.github.io/2021/02/19/software%20test3/2022.2.20/</id>
    <published>2021-02-19T02:25:00.000Z</published>
    <updated>2022-02-20T12:57:59.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、课程目标"><a href="#一、课程目标" class="headerlink" title="一、课程目标"></a>一、课程目标</h2><p>​        1.理解单元测试、集成测试、系统测试的基本测试策略</p><p>​            测试方法。</p><p>​        2.掌握测试用例写作的基本方法。</p><p>​        3.掌握缺陷报告的基本编写方法</p><h2 id="二、单元测试"><a href="#二、单元测试" class="headerlink" title="二、单元测试"></a>二、单元测试</h2><p>​        学习目标：</p><p>​            1）了解桩和驱动的概念</p><p>​            2）了解单元测是的策略</p><p>​        测试对象： 函数</p><h5 id="2-1-什么是函数"><a href="#2-1-什么是函数" class="headerlink" title="2.1    什么是函数"></a>2.1    什么是函数</h5><p>​            函数组成一个软件系统的最小单位，程序中的函数，可以理解为为了完成某个特定功能的代码            集合。</p><p>​            好处：需要该功能的时候，直接调用该函数即可。不用每次重复写这些代码。</p><h5 id="2-2-桩和驱动的概念"><a href="#2-2-桩和驱动的概念" class="headerlink" title="2.2    桩和驱动的概念"></a>2.2    桩和驱动的概念</h5><p>​            eg:有一个1 一个2-1 一个 3-1  1调用2-1  2-1 调用3-1 </p><p>​            如果2-1写好了需要被测 那么需要写一个驱动函数代替1  写一个桩函数代替3-1</p><p>​            桩和驱动是测试人员自己所要编写的</p><p>​            驱动：在被测函数的上层，调用被测函数的作用。</p><p>​            驱动函数的使命：根据测试用例的设计调用被测函数，并且判断被测函数</p><p>​            的返回值是否与测试用例的运行结果相符。</p><p>​            桩：在被测函数的下层，被被测试的函数所调用，代替被测</p><p>​            函数所调用的函数。</p><p>​            桩函数的使命：使得程序能够编译通过，还需要模拟返回被代替函数的</p><p>​            各种返回值（什么时候返回需要根据测试用例的情况来决定）</p><p>​            </p><p>​            思考：如何测试B模块?</p><p>​                                                A</p><p>​                    B                                                     C</p><p>​            D            E                                                F</p><p>​                            G</p><p>​            1）写2个桩模块 , SD去替代D，SE去替代E   SD和SE就叫桩模块</p><p>​            2）写一个驱动模块，Da去替代A</p><p>​        </p><h5 id="2-3-单元测试的策略"><a href="#2-3-单元测试的策略" class="headerlink" title="2.3    单元测试的策略"></a>2.3    单元测试的策略</h5><p>​            2.3.1    孤立的</p><p>​                    不考虑每个单元与其他单元的关系，单独为每一个单元设计驱动和桩，能达到较高的覆                    盖。</p><p>​                    优点：实现简单，覆盖率高</p><p>​                    缺点：效率低，要开发大量的桩和驱动</p><p>​            2.3.2    自顶向下</p><p>​                    思想是分层进行测试，先对最顶层的单元进行测试，把所调用的单元做成桩，再对第二层                    进行测试， 直到所有的单元测完。</p><p>​                    优点：需要开发驱动，效率较高</p><p>​                    缺点：随着被测单元的加入，测试复杂度越来越高。</p><p>​            2.3.3    自底向上</p><p>​                    分层测试，先对最底层单元进行测试，把上层调用被测单元的做成驱动。再对上面一层测                    试，直到测完所有的单元。</p><p>​                    优点：不要开发桩，效率高。</p><p>​                    缺点：底层函数的测试质量对上层函数的测试会产生很大的影响。</p><p>​            2.3.4    混合型    （有自顶向下也有自底向上）</p><h5 id="2-4-集成测试的策略"><a href="#2-4-集成测试的策略" class="headerlink" title="2.4    集成测试的策略"></a>2.4    集成测试的策略</h5><p>​            学习目标：</p><p>​            了解集成测试的层次</p><p>​            了解集成测试的重点</p><p>​            了解集成测试的策略</p><p>​        </p><p>​            2.4.1    集成测试的层次</p><p>​                    模块内集成：函数间</p><p>​                    eg.    电商网站，有哪些模块？</p><p>​                    1    产品展示模块；    2    商品发布模块； 3     网上支付模块；    4    订单模块</p><p>​                    5    购物车模块；    6    商品管理模块；    7    会员注册模块；    8    营销模块</p><p>​                    9    搜索模块；        10    售后模块；        11    登录模块；                </p><p>​                    和单元测试的区别?    关注函数之间的接口；</p><p>​                    <a href="https://blog.csdn.net/qq_34462436/article/details/102155492">模块间集成</a></p><p>​                    关注模块之间的接口</p><p>​                    1）购物车模块和登录模块的交互</p><p>​                    2）产品展示模块和营销模块的交互</p><p>​                    3）注册模块和登录模块的交互</p><p>​                    4）订单管理模块和支付模块的交互</p><p>​                    ……</p><p>​                    <a href="https://blog.csdn.net/qq_34462436/article/details/102155492">子系统集成</a></p><p>​                    1）前端子系统    2）后端子系统</p><p>​                    </p><p>​            2.4.2    集成测试的重点</p><p>​                    集成后的功能</p><p>​                    内部接口</p><p>​            </p><p>​            2.4.3    集成测试的策略</p><p>​                    1）大爆炸集成</p><p>​                            一次性将所有组件集成</p><p>​                            优点：操作简单，可多人并行工作。</p><p>​                            缺点：不支持故障隔离；一次性集成的成功的概率很低；即使一次性集成成功，</p><p>​                                        很多接口上的测试会被遗漏，覆盖度不够。</p><p>​                    2）自顶向下的集成</p><p>​                            1.深度优先：先将某个完整功能的相关单元自上而下依次集成，再做另外一个。</p><p>​                            2.广度优先：不区分功能，按总体结构逐层向下验证。</p><p>​                            优点：支持隔离，较早的验证主控制的问题。</p><p>​                            缺点：进行桩的开发和维护</p><p>​                    </p><p>​                2.4.5    自底向上集成</p><p>​                        先从最底层集成再逐层往上集成</p><p>​                        优点：支持故障隔离</p><p>​                        缺点：对顶层的验证推迟了，设计上的错误不能及时发现。</p><p>​            2.4.6    三明治集成</p><p>​                        将被测软件分成三层，中间层是目标层，之上的采用自顶向下的策略，之下的采用</p><p>​                        自底向下的策略，最终在目标层汇合。</p><p>​        </p><p>​            2.4.7    基于功能集成</p><p>​                    从功能角度出发，按功能的关键程度对功能模块进行集成</p><p>​                    优点：能尽早的看到功能的实现</p><p>​                    缺点：比大爆炸集成慢</p><p>​                                继承了大爆炸集成的缺点</p><h2 id="三、系统测试"><a href="#三、系统测试" class="headerlink" title="三、系统测试"></a>三、系统测试</h2><p>​        学习目标</p><p>​        了解什么是系统测试</p><p>​        理解常用的系统测试类型</p><p>​        了解系统的测试环境</p><p>​        了解系统测试的执行</p><h5 id="3-1-什么是系统测试？"><a href="#3-1-什么是系统测试？" class="headerlink" title="3.1    什么是系统测试？"></a>3.1    什么是系统测试？</h5><p>​            测试对象：整个软件系统</p><p>​            测试依据：需求规格说明书SRS</p><p>​            重点：软件系统是否满足需求规格说明书</p><p>​            方法：黑盒</p><p>​            系统？</p><p>​            架构说明转载：<a href="https://blog.csdn.net/qq_34462436/article/details/102155492">https://blog.csdn.net/qq_34462436/article/details/102155492</a></p><p>​            1）B/S 架构 browser / server 即浏览器和服务器<em>架构</em>模式</p><p>​            2）C/S 架构  client / server  <em>CS架构</em>一般指服务器-客户机。客户端/服务器模式</p><p>​            3）飞秋 p2p</p><p>​            4）嵌入式：嵌入到硬件设备中的软件</p><p>​            </p><h5 id="3-2-系统测试环境"><a href="#3-2-系统测试环境" class="headerlink" title="3.2    系统测试环境"></a>3.2    系统测试环境</h5><p>​            3.2.1    硬件</p><p>​            PC：内存，硬盘，显卡，cpu    …</p><p>​            服务器：电脑，配置高</p><p>​            路由器和交换机：    路由器工作在<strong>网络层</strong>，交换机工作在<strong>链路层</strong>；路由器依靠ip地址寻址转发</p><p>​            交换机依靠mac地址来过滤和转发。路由器用于连接局域网和外网，交换机用于局域内网。</p><p>​            PDA    （p-personal    d-digital    a-assistant）：除了拥有传统掌上电脑基本信息处理功能之            外，还增加了很多专业功能。</p><p>​                    功能：条码扫描、RFID（无线射频技术）读写、指纹采集    …</p><p>​            对专业的设备而言，硬件还包括设备的硬件组成部分。比如X光机    …</p><p>​            3.2.2    软件</p><p>​                    操作系统（内核管理硬件的启动）</p><p>​                    服务器（应用服务器，web服务器）</p><p>​                    数据库：关键型数据库（表与表之间有复杂的关联关系）：mysql,sql-server,oracle</p><p>​                                    非关键型数据库    NoSql（适合非结构化的数据的处理，文章，评论）</p><p>​                                    ：Redis    MongoDB</p><p>​                    被测软件</p><p>​                    测试脚本：自动化测试    python    javascript    vbscript    </p><p>​                    测试程序</p><p>​                    </p><h5 id="3-3-环境分类"><a href="#3-3-环境分类" class="headerlink" title="3.3    环境分类"></a>3.3    环境分类</h5><p>​                    主测环境：chrome浏览器</p><p>​                    辅助环境：firefox    ie    …  </p><p>​                    </p><p>​                    测试环境</p><p>​                    灰度环境（仿真环境）</p><p>​                    真实环境</p><h5 id="3-4-系统测试数据的准备"><a href="#3-4-系统测试数据的准备" class="headerlink" title="3.4    系统测试数据的准备"></a>3.4    系统测试数据的准备</h5><p>​                    1.利用产品的数据（用户脱敏后的真实数据，网站的订单信息，商品信息）</p><p>​                    2.手工构造</p><p>​                    3.工具生成</p><p>​                    4.随机数</p><p>​                    5.    …</p><h5 id="3-5-系统测试过程"><a href="#3-5-系统测试过程" class="headerlink" title="3.5    系统测试过程"></a>3.5    系统测试过程</h5><p>​                    四个活动</p><p>​                    1）<a href="https://blog.csdn.net/qq_34462436/article/details/102155492">系统</a>测试计划</p><p>​                        角色：测试组长、资深测试、测试经理</p><p>​                        内容：测试范围、内容、进度、人员分工、通过标准</p><p>​                        输出：《系统测试计划》</p><p>​                    2）<a href="https://blog.csdn.net/qq_34462436/article/details/102155492">系统</a>测试设计</p><p>​                        角色：资深测试工程师、测试leader</p><p>​                        内容：怎么做</p><p>​                        输出：《系统测试方案》</p><p>​                    3）<a href="https://blog.csdn.net/qq_34462436/article/details/102155492">系统</a>测试实现</p><p>​                        角色：测试工程师</p><p>​                        内容：编写系统测试用例、准备系统测试数据、准备系统测试脚本</p><p>​                        输出：《系统测试用例》、系统测试脚本、系统测试数据、《系统测试规程》</p><p>​                    4）<a href="https://blog.csdn.net/qq_34462436/article/details/102155492">系统</a>测试的执行</p><p>​                        角色：测试过程师</p><p>​                        内容：搭建系统测试环境，执行系统测试用例、记录系统测试结果</p><p>​                        输出：《缺陷报告》、《系统测试报告》、《测试小结》</p><h5 id="3-6-系统测试类型"><a href="#3-6-系统测试类型" class="headerlink" title="3.6    系统测试类型"></a>3.6    系统测试类型</h5><p>​                    3.6.1    功能测试</p><p>​                            业务流程、场景测试（场景指用户操作软件的过程，将多个功能串成业务流程）</p><p>​                            eg：购物流程</p><p>​                            单功能测试：单一功能的测试，不考虑功能的交互</p><p>​                            功能交互测试：  eg1.    购物网站    eg2.    手机功能交互（人脸识别解锁、人脸识别                            支付、微信发朋友圈、游戏中来电、一边听歌一边上网）    </p><p>​                    3.6.2    性能测试</p><p>​                        1）常见的性能测试指标</p><p>​                            响应时间，资源占用率、容量</p><p>​                            负载测试：产品在不同的并发量下的性能表现</p><p>​                            <strong>压力测试</strong>：<a href="https://blog.csdn.net/qq_34462436/article/details/102155492">长时间超大负荷</a>运行被测软件时的性能表现和可靠性表现</p><p>​                            <strong>稳定性测试</strong> </p><p>​                            容量测试：产品承受数据量的最大能力</p><p>​                            </p><p>​                    3.6.3    界面测试（UI）</p><p>​                            <a href="https://blog.csdn.net/qq_34462436/article/details/102155492">元素</a></p><p>​                                元素的类型：下拉列表、文本框、单选框、复选框、表格、链接、箭头、按钮…</p><p>​                                元素的显示：光标的默认位置、输入回显、文本框的提示信息…</p><p>​                                元素处理响应：点击按钮弹出窗口、点击下拉列表显式列表项、光标移动发生颜色                                变化…</p><p>​                            <a href="https://blog.csdn.net/qq_34462436/article/details/102155492">布局</a></p><p>​                                元素的位置</p><p>​                                元素的间距</p><p>​                                自适应</p><p>​                            <a href="https://blog.csdn.net/qq_34462436/article/details/102155492">快捷键</a></p><p>​                                    Tab键</p><p>​                                    F12/F1/F5</p><p>​                                    Ctrl+c/v</p><p>​                                    右键菜单</p><p>​                                    回车…</p><p>​                    </p><p>​                    3.6.4    兼容性测试</p><p>​                            考虑在不同环境下的功能测试和界面测试</p><p>​                            1）操作系统</p><p>​                            pc：</p><p>​                            windows    7/10</p><p>​                            linux : Ubuntu 、Centos</p><p>​                            mac  os</p><p>​                            移动端：android    ios</p><p>​                            2）浏览器</p><p>​                            pc端：chrome   firefox    IE</p><p>​                            移动端：UC  Safari    </p><p>​                            3）分辨率</p><p>​                                笔记本显示器，pc显示器</p><p>​                            4）网络环境</p><p>​                                wifi    5g    4g    3g    2g</p><p>​                                兼容测试策略：</p><p>​                                主测环境，辅测环境</p><p>​                                 </p><p>​                    3.6.5    安全性测试</p><p>​                            1）数据的安全：用户的敏感数据加密处理（加密存储，加密传输）</p><p>​                            2）权限的安全：操作权限（修改，新增，删除…），数据权限，</p><p>​                            3）安全漏洞：</p><p>​                                Burpsuit：一款集成化的渗透测试工具，完成web应用程序的渗透测试和攻击</p><p>​                                Appscan：可以对网站等web应用进行自身化的应用安全扫描和测试</p><p>​                                Wvs：（web vulnerability scanner）：自动化的web应用程序安全测试工具</p><p>​                    3.6.6    安装测试</p><p>​                            安装前：检查安装文件是否齐全，（安装程序和文件，文档）</p><p>​                                            安装环境的准备</p><p>​                            安装中：各种参数的设置，不同的安装过程</p><p>​                            安装后：测试安装是否完整；测试安装好的软件是否可以运行</p><p>​                    3.6.7    可靠性测试</p><p>​                            1）异常测试</p><p>​                                断网，断电、硬件损坏、故障植入</p><p>​                            2）稳定性测试    -    产品在上时间高负载运行下的产品性能表现和可靠性表现</p><p>​                            </p><h5 id="3-7-系统测试执行过程"><a href="#3-7-系统测试执行过程" class="headerlink" title="3.7    系统测试执行过程"></a>3.7    系统测试执行过程</h5><p>​                1）预测试：检查<strong>基本功能</strong>是否正常，也叫冒烟测试</p><p>​                2）转正式系统测试（预测试是否通过，用例怎么样？测试人员到位了吗？测试工具到位了                    吗?…）</p><p>​                3）系统测试：系统测试的执行</p><p>​                4）填写测试记录，记录测试用例的执行结果 （pass-通过 、fail-不通过 、block因为上层的                    缺陷被阻塞而没有执行 、Na（不适用本次的测试-Not-Applicable））    </p><p>​                5）提交缺陷报告：Jira、禅道、CQ（ClearQuest）Quality Center</p><p>​                6）测试日报：汇报每天的测试执行情况</p><p>​                7）编写测试报告，做测试总结</p><h2 id="四、测试用例的写作"><a href="#四、测试用例的写作" class="headerlink" title="四、测试用例的写作"></a>四、测试用例的写作</h2><p>​            目标：掌握测试用例的编写要求和方法</p><p>​            </p><h5 id="4-1-什么是测试用例（test-case）"><a href="#4-1-什么是测试用例（test-case）" class="headerlink" title="4.1 什么是测试用例（test case）"></a>4.1 什么是测试用例（test case）</h5><p>​                测试工程师进行测试执行工作的指导性文件，通常一个测试用例是由一组操作步骤来组成。</p><p>​                目的是测试系统的某一个需求。</p><p>​            </p><h5 id="4-2-测试用例有什么用"><a href="#4-2-测试用例有什么用" class="headerlink" title="4.2    测试用例有什么用"></a>4.2    测试用例有什么用</h5><p>​                1）防止测试的遗漏</p><p>​                2）防止测试的重复</p><p>​                3）复用</p><p>​                4）发现缺陷        </p><p>​                5）估算工作量</p><h5 id="4-3-测试用例怎么写？"><a href="#4-3-测试用例怎么写？" class="headerlink" title="4.3    测试用例怎么写？"></a>4.3    测试用例怎么写？</h5><p>​                4.3.1    测试用例要包括哪些要素？</p><p>​                        1）用例编号</p><p>​                            测试阶段—-模块—-功能—–编号</p><p>​                            eg.    ST_ShopCart_ClearFunc_001</p><p>​                        2）测试类型</p><p>​                            UT单元测试/    IT集成测试/    ST系统测试/    AT验收测试</p><p>​                        3）用例的标题</p><p>​                            购物车商品的删除</p><p>​                        4）重要级别（优先级）</p><p>​                            1、2、3</p><p>​                        5）预置条件</p><p>​                            eg.    用户成功登录，添加一个商品到购物车</p><p>​                        6）测试输入</p><p>​                            数据？</p><p>​                        7）操作步骤</p><p>​                            1.进入购物车</p><p>​                            2.点击删除按钮，删除购物车的商品</p><p>​                            3.检查购物车是否清空</p><p>​                        8）预期结果</p><p>​                            eg.    购物车被清空</p><p>​                        9）其他属性：用例执行结果；关联的bug;    执行人；执行时间    评审状态等…</p><p>​            </p><h2 id="五、缺陷管理"><a href="#五、缺陷管理" class="headerlink" title="五、缺陷管理"></a>五、缺陷管理</h2><h5 id="为什么要提交缺陷？-不会造成缺陷的遗漏，便于缺陷的跟踪，便于分析缺陷"><a href="#为什么要提交缺陷？-不会造成缺陷的遗漏，便于缺陷的跟踪，便于分析缺陷" class="headerlink" title="为什么要提交缺陷？    不会造成缺陷的遗漏，便于缺陷的跟踪，便于分析缺陷"></a>为什么要提交缺陷？    不会造成缺陷的遗漏，便于缺陷的跟踪，便于分析缺陷</h5><p>​        缺陷的类型：错误error    缺陷    defect     失效    failure    故障     fault</p><h5 id="5-1-缺陷报告的内容"><a href="#5-1-缺陷报告的内容" class="headerlink" title="5.1    缺陷报告的内容"></a>5.1    缺陷报告的内容</h5><p>​            1）BUG标题</p><p>​            2）BUG详情（重现步骤、实际结果、预期结果）</p><p>​            3）BUG属性（严重程度、优先级、缺陷状态–新建—打开open—-已分配Assigned—–已修复                resolved—重新打开reopen–拒绝—-延期—-已验证Verified—-关闭close  ）</p><p>​            测试用例编号</p><p>​            需求编号</p><p>​            提交日期</p><p>​            提交人</p><p>​            测试环境</p><p>​            测试阶段</p><p>​            测试类型</p><p>​            测试版本</p><p>​            产品型号</p><p>​            项目编号</p><p>​            </p><h5 id="5-2-缺陷管理的工具"><a href="#5-2-缺陷管理的工具" class="headerlink" title="5.2    缺陷管理的工具"></a>5.2    缺陷管理的工具</h5><p>​            Jira    禅道        QC    CQ    </p>]]></content>
    
    
    <summary type="html">关于软件测试的笔记</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>软件测试</title>
    <link href="https://secondarylove.github.io/2021/02/17/software%20test/index/"/>
    <id>https://secondarylove.github.io/2021/02/17/software%20test/index/</id>
    <published>2021-02-17T02:25:00.000Z</published>
    <updated>2022-02-20T13:12:23.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一次课"><a href="#第一次课" class="headerlink" title="第一次课"></a>第一次课</h2><p>课程目标</p><ol><li>   理解什么是测试</li><li>   理解软件生命周期</li><li>   了解常见研发组织</li><li>   理解什么是缺陷</li></ol><p>1.实例1<br>    极域出现网络适配器未找到</p><pre><code>问题：  1、软件版本    2、软件的安装过程    3、软件安装完成后的参数有没有设置正确    4、网卡，网络环境的测试</code></pre><p>  实例2 买衣服</p><pre><code>1）计划 - 羽绒服，价位多少？600-1000？品牌2）去哪里买 - 去商场买3）颜色：红色，灰色，黑色4）款式：长款，中长款，短款5）材质：羽绒80% 6）尺寸7）防水性 透气性8）洗涤方式9）价格10）售后，质保11）评价</code></pre><h2 id="一、-软件测试的目的"><a href="#一、-软件测试的目的" class="headerlink" title="一、 软件测试的目的"></a>一、 软件测试的目的</h2><pre><code>1.证明软件是可用的2.检测发现缺陷3.预防缺陷 - 分析已发现的bug,避免bug的重复出现</code></pre><h2 id="二、什么是软件测试"><a href="#二、什么是软件测试" class="headerlink" title="二、什么是软件测试"></a>二、什么是软件测试</h2><pre><code>IEEE  软件工程技术标准对软件测试的定义：采用手工或者自动化的手段，运行软件或直接观察软件的过程其目的是检验产品是否满足用户的需求，或弄清楚产品实际和需求之间的差别测试方法：手工或者自动化测试过程：运行软件或者直接观察软件运行的现象，或不运行软件，观察文档测试的根本目的：检验产品是否满足用户的需求：搞清楚产品实际和需求之间的差别问题：什么是缺陷缺陷：    不符合预期    错误:-error-    指在软件生存期内的不希望或不可接受的人为错误，其结果是                导致软件缺陷的产生。    缺陷:-defect-    软件或文档中不符合预期的表现，    失效:-failure-    功能部件执行其规定功能的能力丧失    故障:-fault-    在正式环境（生产环境）下缺陷暴露出来引发故障缺陷分类    1）额外实现的不需要的 -做多了    2）实现缺失 -做少了    3）实现错误 -做错了    4）可优化   -做的不完美</code></pre><h2 id="三、软件的生命周期"><a href="#三、软件的生命周期" class="headerlink" title="三、软件的生命周期"></a>三、软件的生命周期</h2><p>​    </p><pre><code>3.1 计划    角色：项目经理（产品经理）    工作内容：确立项目的目标，调研，沟通，评估可行性，资源，成本，进度，收益等。    输出：《项目计划》 愿景，使命，目标3.2 需求分析    角色：需求人员（项目经理，需求分析师，产品经理）    工作内容：解决软件做什么的问题，分析具体需求，逐步细化和定义    显式需求-明确提出    隐式需求-没有提出来但实际需要    输出：《需求规格说明书》《SRS 软件需求规格说明书》  Software Requirements Specification3.3 设计    角色：开发人员（架构师）    工作内容：怎么实现，如何实现（how）对系统 - 子系统 -模块 -函数进行    逐层设计    输出：《概要设计说明书-HLD》  high Level Design    《详细设计说明书-LLD》 Low Level Design3.4 编码    角色：开发工程师    工作内容：编写代码coding      输出：代码，可运行的程序3.5 测试    角色：测试工程师    工作内容：检查软件的质量    输出：《测试报告》《测试计划》《测试用例》《测试规程》《缺陷报告》3.6 运维    角色：运维人员，技术支持    工作内容：产品的运行维护，安装部署，升级更新，线上问题排查，培训。      输出：《运维报告》</code></pre><h2 id="四、瀑布模型"><a href="#四、瀑布模型" class="headerlink" title="四、瀑布模型"></a>四、瀑布模型</h2><pre><code>基于瀑布模型的软件生命周期    计划 需求（AT） 分析（st） 设计 (IT) 编码                                      测试 运维 特点：    1）串行的流程    2）测试到后期介入    3）一个测试师可负责多个项目    4）前期阶段做的越完善，后期的修改成本越低，交付质量就越高    缺点：    1）风险往往延至后期才能显露出来，失去及早纠正的机会    2）只能在项目后期才能看到成品    3）对需求变更的适应能力差    适合复杂度低，需求稳定的项目，通常周期较短</code></pre><h2 id="五、螺旋模型"><a href="#五、螺旋模型" class="headerlink" title="五、螺旋模型"></a>五、螺旋模型</h2><pre><code>瀑布模型的迭代版特点：    1）每一个螺旋类似于一个瀑布模型    2）分多次进行交付，在项目早期就能看到产品的雏形    3）风险能较早的暴露出来    4）对需求变更的适应能力更好缺点：    1）迭代次数多因而开发成本高，延迟最终交付的时间    2）适合复杂度高，需求可能有一定变化的项目，通常周期较长。</code></pre><h2 id="六、敏捷模型"><a href="#六、敏捷模型" class="headerlink" title="六、敏捷模型"></a>六、敏捷模型</h2><pre><code>螺旋模型的加速版本特点：        1）迭代周期短，1-2周；2)弱化文档，强调沟通，强调团队合作；    3）用户第一    适合需求不确定的项目</code></pre><h2 id="七、常见的研发组织"><a href="#七、常见的研发组织" class="headerlink" title="七、常见的研发组织"></a>七、常见的研发组织</h2><p>​    </p><pre><code>1）开发部--开发工程师前端开发工程师：h5页面；安卓：ios后端开发工程师：java python php c++ c# .net...数据库...2)测试部测试工程师 -QC测试开发工程师3）产品部产品经理需求工程师UI设计师4）质量部QA SQACMO 配置管理项目管理员：进度监督，进度协调</code></pre><h2 id="八、组织架构"><a href="#八、组织架构" class="headerlink" title="八、组织架构"></a>八、组织架构</h2><pre><code>按职能按项目矩阵混合类</code></pre><h2 id="九、测试过程"><a href="#九、测试过程" class="headerlink" title="九、测试过程"></a>九、测试过程</h2><p>​     </p><pre><code>9.1 学习目标    理解测试的四个阶段    理解测试的四个活动        理解测试的模型-双v模型9.2 测试的四个阶段单元测试 集成测试 系统测试 验收测试    9.2.1 单元测试 UT    u-unit T-test     针对软件系统的最基本单位进行测试（函数、类）        1.测试依据：《详细设计说明书》 LLD    2.测试对象：函数和类    3.测试重点：检查实现出来的代码是否和详细设计一致，            函数内部逻辑，各个函数的功能    4.测试方法：白盒测试为主    5.测试完整性的评估标准：逻辑覆盖率（语句的覆盖，判定的覆盖，路径的覆盖...）    6.由谁来执行：        一般由开发人员来执行，或者测试人员                                                                                                                          6.由谁来执行</code></pre><p>​            </p><pre><code>    9.2.2 集成测试  IT    将测试的每个单元，模块，子系统进行组装，检查他们之间的数据传递是否正确        也叫做组装测试。        1.测试依据： &#123;% label 《概要设计说明书》 HLD blue %&#125;    2.测试对象：接口    3.测试重点：检查实现出来的模块代码是否和概要设计保持一致            函数之间的相互调用是否正确，接口是否正确            模块的功能是否正确    4.测试方法：灰盒测试（介于白盒黑盒之间）    5.测试完整性的评估标准：接口覆盖率    6.由谁来执行：测试人员或者开发人员        9.2.3 系统测试 ST    将集成的系统作为一个元素和其他的软硬件结合一起做综合的测试叫系统测试。    （功能性、性能、兼容、可靠性、安全性....）        1.测试依据:SRS 《软件需求规格说明书》    2.测试对象：整个的软件系统    3.测试重点： 检查整个软件系统实现出来的功能性能是否和需求保持一致    4.测试方法：以黑盒测试为主    5.测试完整性的评估标准：需求覆盖率    6.由谁来执行：测试人员    9.2.4 验收测试 AT acceptance test    一般是指由客户参与的测试（第三方，用户）        1.测试依据:用户的原始需求，任务书，用户手册    2.测试对象：整个的软件系统    3.测试重点：检查整个软件系统实现出来的功能性能是否和用户需求保持一致    4.测试方法-分类        a.正式验收测试：由第三方评测机构来执行        b.用户验收测试：由用户执行            b1.α测试：用户到公司的内部进行测试使用                   受控：参与的人员经过筛选的，少量的                   使用的环境也是受控的，内部操作受控，在项目组的成员的陪同下进行，需要提供反馈                        例子（eg）：游戏封测：版本是未成熟的，有很多bug,禁止用户注册，只提供一些账号分给玩家试玩，                    如果发现了bug一定要告诉官方，官方才能修改.游戏内侧经历了封测，游戏进一步完善，                    给大部分玩家玩，账号难注册，返回bug            b2:β测试：用户场所进行测试                   不受控：参与的人员较多，使用真实环境 自由操作，不受控 可以反馈            eg:游戏公测：向广大玩家公开，注册的账号数量也没有限制，公测初期是免费的，随着玩家数量的增加，               但到了后期会逐渐的开始收费.    5.测试完整性的评估标准:用户需求覆盖率</code></pre><p>​        </p><pre><code>    9.2.5 对比        1)时间顺序不同        2)测试关注点不同        3)测试依据不同        4)测试完整性的评估标准不同        5)测试方法不同9.3 测试的四个活动    每个测试阶段，都可以细分为4个测试活动，这4个活动在每个阶段按时间顺序来进行    9.3.1 测试计划                角色：测试经理，测试组长(leader)                工作内容：从管理的角度来规划和控制整个测试工作的展开              测试范围，时间速度，人员分工，通过的标准        输出：《测试计划》 从管理的角度来规划和控制整个测试工作的展开    9.3.2 测试设计        角色：测试工程师                工作内容：选择什么样的测试方法，选择什么样的测试工具，选择什么样的测试策略        输出：《测试方案》 从技术角度来规划和控制整个测试工作    9.3.3 测试实现        角色：测试工程师                工作内容：编写测试用例，编写测试脚本，准备测试数据...        输出：《测试用例》 测试脚本 测试数据 测试规程...    9.3.4 测试执行        角色：测试工程师                工作内容：搭建测试环境；              准备测试的数据              执行测试用例并记录测试用例的执行结果                              提交缺陷报告                            输出：《缺陷报告》 《测试报告》 《总结报告》</code></pre><h2 id="十、回归测试"><a href="#十、回归测试" class="headerlink" title="十、回归测试"></a>十、回归测试</h2><pre><code>10.1 目的        验证缺陷是否修复；检查是否引入了新的缺陷10.2 回归测试的策略    10.2.1 完全回归        将所有的测试用例执行一次，工作量很大，一般很少采用    10.2.2 选择性回归        1) 覆盖修改法:哪里修改了就回归哪里        2)周边影响法：针对比较复杂的模块的修改，不仅要对测试修改过得内容，还要分析本次修改可能对其它哪些模块也产生                  ，凡是认为有影响的模块，也需要做回归测试。        3)指标达成法：按照一定的标准来选择需要回归测试的内容                  如：上次提交的所有缺陷对应的测试用例  100%                  有影响的模块对应的测试用例        100%                  核心模块的1、2级测试用例         100%</code></pre><h2 id="十一、测试模型"><a href="#十一、测试模型" class="headerlink" title="十一、测试模型"></a>十一、测试模型</h2><pre><code>11.1 V模型    本质上和瀑布模型一致    特点：        测试阶段和开发人员的工作对应        测试介入较晚        开发和测试串行工作11.2 双V模型    特点：                测试和开发可以并行开展工作        测试介入较早        测试准备和测试执行分离        越早准备越晚执行</code></pre><h2 id="十二、测试方法"><a href="#十二、测试方法" class="headerlink" title="十二、测试方法"></a>十二、测试方法</h2><pre><code>12.1 学习目标了解黑盒、白盒、灰盒、测试的方法了解静态、动态测试了解人工、自动化测试12.2 黑盒、白盒、灰盒测试    黑盒：把测试对象看成一个黑盒，只考虑整体的特性，不考虑内部的具体实现    主要使用在系统测试阶段    黑盒测试用例的测试方法：    等价类、边界值、判定表、正交实验、状态迁移、因果图、错误猜测...    白盒：将被测产品看做一个透明的盒子，针对内部逻辑进行测试        特点：只关注被测对象的实现细节，不关注外在特性。    主要用在单元测试阶段</code></pre><p>​        </p><pre><code>    灰盒：介于白盒和黑盒之间的一种测试                特点：既会关注被测对象的实现细节，也灰关注外在特性        一般用在集成测试阶段12.3 静态测试与动态测试    根据是否运行被测软件划分为静态测试与动态测试    静态测试 - 不运行被测软件                人工静态：同行评审，SRS HLD LLD 代码 测试计划 等        自动化静态：如编译    动态测是 - 运行被测软件        功能、性能、安全、兼容、易用、可靠性、可维护性、可移植性12.4 人工测试与自动化测试    人工测试是自动化测试的基础    自动化测试的优点：            稳定、速度快、效率高、解放人才                自动化测试保证软件的基本可用，而不是去发现更多的bug    自动化测试的局限性：        没有想象力、也没有创造力，也没有发散性思维        比如不合适审美类的测试        不合适需求不稳定，界面经常发生变化                不合适功能不稳定的时间进行测试        不合适不需要重复执行的测试        不合适周期短的测试项目</code></pre><p>​            </p><pre><code>        适合什么样的测试？        界面稳定，功能稳定，重复性高        回归测试：冒烟测试（预测试）、性能测试</code></pre>]]></content>
    
    
    <summary type="html">关于软件测试的笔记</summary>
    
    
    
    
  </entry>
  
</feed>
